=pod

Everybody. Get In Line! - I<Making Flippy Floppy> Talking Heads

=head1 Extending Perl the Easy Way with Inline.pm

I started out my career as an IBM assembly language programmer. You know, hexadecimal arithmetic, bit-level operations, debugging 500 page core dumps printed on "green-bar". The cool thing about assembly language is that you can do I<anything>. You could write a nice menu-based hyper-linking user interface, that stores its data on your own homemade mass-storage device. What sucks about assembly is that you I<have> to do I<everything>. Programming C<A = B + C> takes more than one punch-card.

After a while, I spent most of my time developing programming tools and language extensions. Any hacker worth his salt cannot code something the same way more than 3 times without writing an abstraction to do it for her. I would write things to turn concepts like memory allocation, I/O, and database access into assembly language one-liners with some object oriented behavior.

When I switched languages to Perl about 3 years ago, it was a very natural transition. What??? Assembly to Perl? Natural? Definitely! I soon found that although I could accomplish almost anything I wanted to, I didn't have to do all the work. Perl has so many powerful built-in features and extensions. Regular expressions, run-time evaluation, C<LWP.pm> and C<CGI.pm> to name a few. If I needed to write my own protocol or device level stuff, I could generally do that too.

Everything was proceeding swimmingly. Then one day, I needed to make my Perl code work with someone else's C code. I had heard that Perl has facilities for doing such things. I assumed that since Perl was so awesome, it must be really easy to do. Something along the lines of:

    $question = "How soon is now?";
    print "And the answer is: ", &ask_Mr_Wizard($question);
    exit;

    BEGIN :C {
        char* ask_Mr_Wizard(char* q) {
	    /* omniscient C code omitted */
            return a;
	}
    }

Boy was I in for a surprise. It turned out that I needed to create a separate module, a separate C file, a "glue code" file in a language called XS, a type mapping file, and a C<Makefile> generating file. <FOOTNOTE #1> Then I needed to absorb the content of over a half dozen lengthy C<perldoc> man pages, read a couple of books, and muck about in the Perl source code for examples. All very interesting stuff I assure you, but all I wanted to do was ask Mr Wizard a question. If Perl is supposed to "make simple things simple, and hard things possible", then this must have been bordering on the impossible.

=head2 Introducing Inline.pm

Inspired by the many presentations of Damian Conway, at this past Summer's Perl 4.0 Conference, I decided to create a module that would let me include other programming languages directly in my Perl code in much the same manner shown above. What impressed me about Dr. Conway's modules, was that he tackled problems of immense magnitude, with solutions of equal simplicity, or in Damian's words "DWIMity" (Do What I Mean). I decided to call this module C<Inline.pm>. It is fitting that much of the work done by this module is accomplished using Damian's C<Parse::RecDescent>.

Enough talk. Let's check this thing out. Here's a simple but complete program:

    # rithmatick.pl
    print "9 + 16 = ", add(9, 16), "\n";
    print "9 - 16 = ", subtract(9, 16), "\n";
 
    use Inline C => <<'END_OF_C_CODE';
    
    int add(int x, int y) {
      return x + y;
    }
 
    int subtract(int x, int y) {
      return x - y;
    }
   
    END_OF_C_CODE

That's it! Just run it like any other Perl script and it will print:

    9 + 16 = 25
    9 - 16 = -7

I've just managed to accomplish something in ten lines, that used to take two!

But the point is that you can now jump painlessly from Perl-space to C-space and back. Once you're in C-space you can do whatever floats your boat. Like write a super speedy algorithm, invoke legacy code through an API, or access the entire internals of C<perl>.

But how is this possible? Don't you need to compile and link the C code? Wouldn't that make the script extremely slow? How do the Perl variables get converted to C variables and back? How can C functions be called like Perl subroutines?

That's the DWIMity kicking in. All the hairy details are handled for you. You just say what you need to say and let C<Inline> do the rest. 

The first time you run this script, C<Inline> does everything the hard way. It analyzes your C code, creates all those different files, compiles it, links it, and finally loads the executable object. On my Linux machine, this causes a 3-4 second delay in execution time. The second time you run it, it's lightning fast. That's because C<Inline> caches the executable object on disk. You can change your script as much as you like, and as long as you don't touch the C code, C<Inline> will use the cached version. As soon as you I<do> change the C code, C<Inline> will recompile it on the next run.

=head2 I'd Like To Buy A Vowel

Let's look at another example. This one is only slightly more complex. The script, C<vowels.pl>, takes a file name from the command line and prints the ratio of vowels to letters in that file. C<vowels.pl> uses an C<Inline> C function called C<vowel_scan>, that takes a string argument, and returns the percentage of vowels as a floating point number between 0 and 1. It handles upper and lower case letters, and (true to my IBM roots) ASCII and EBCDIC. It is also quite fast. (Check out the benchmarks at the end of the article)

    # vowels.pl
    use Inline;
    Inline->import(C => <DATA>);   # "eval" the C code at run time
    
    $filename = $ARGV[0];
    die "Usage: perl vowels.pl filename\n" unless -f $filename;
    
    $text = join '', <>;           # slurp input file
    $vp = vowel_scan($text);       # call our function
    $vp = sprintf("%03.1f", $vp * 100);  # format for printing
    print "The letters in $filename are $vp% vowels.\n";
    
    __END__

    /* Find percentage of vowels to letters */
    double vowel_scan(char* str) {
      int letters = 0;
      int vowels = 0;
      int i = 0;
      char c;
      char normalize = 'a' ^ 'A';  /* Assembly programmer trick :-) */
      /* normalize forces lower case in ASCII; upper in EBCDIC */
      char A = normalize | 'a';
      char E = normalize | 'e';
      char I = normalize | 'i';
      char O = normalize | 'o';
      char U = normalize | 'u';
      char Z = normalize | 'z';
    
      while(c = str[i++]) {
        c |= normalize; 
        if (c >= A && c <= Z) {
          letters++;
          if (c == A || c == E || c == I || c == O || c == U)
            vowels++;
        }
      }
    
      return letters ? ((double) vowels / letters) : 0.0;
    }

Running this script produces:

    > perl vowels.pl /usr/dict/words 
    The letters in /usr/dict/words are 37.5% vowels.

Although this is just another example of calling a C function as if it were a Perl subroutine, it introduces a couple new concepts. 

First, notice that the syntax for invoking C<Inline> is different. The C source code text has been put below the C<__END__> line which means that it is accessible to the script through the C<DATA> filehandle. Unfortunately, you can only read from the C<DATA> filehandle at run time, and C<use> is a compile time directive. Fortunately, in Perl, TMTOWTDI. Since 

    use Foo(LIST);

is just another way of saying 

    BEGIN { require Foo; Foo->import(LIST) }

we can invoke C<Inline> at run time by calling C<import> manually. And thus, use the C<DATA> filehandle. That gives us a very clean way to organize our C<Inline> source code. 

Second, there are two new data types that C<Inline> is binding to: C<double> and C<char*>. Now I'll introduce I<all> of the C data types that C<Inline> supports. They are:

    int
    long
    double
    char*
    SV*

That's it? That's all you need! <FOOTNOTE #2> C<int> and C<long> are for integer scalars, C<double> is for floating point scalars, and C<char*> (usually pronounced "Char Star" in social settings) is for strings. C<SV*> is a generic Perl type that covers "anything else" like hash references, for instance. It will be covered in detail in the following sections. These types provide a very simple interface that can be expanded to handle the most complex situations. Kind of like Perl itself.

At this point, your optimism for having C<Inline> solve your real life needs, is probably inversely proportional to your knowledge of C, XS and Perl internals. "XS provides a lot more type-mapping and functionality", you say. If you're skeptical, that's good. Stick with me until the C<__END__> and I just might convince you that C<Inline> is right for you.

=head2 TAFWTDI 

There are four ways to do it. To call C functions in Perl context that is. 

C functions typically take a fixed number of arguments as input, and produce one or zero return values. When a C function needs to return multiple values, it has the caller pass in the return values "by reference". Perl, on the other hand, almost always returns multiple values as a list. This confronts us with four different situations in C<Inline>:

=over 4

=item 1

    int foo(int i, double n, char* str) {

This is the simplest case. The function, C<foo>, takes an exact number of input arguments and returns one value. All of the Perl to C conversions happen automatically. The previous examples were both of this type.

=item 2

    void foo(int i, double n, char* str) {

In C, C<void> normally means that the function doesn't return anything. C<Inline> gives special meaning to C<void>. It is used to indicate that the function can return any number of values (including zero). This is the way you return a list. It is also less automatic. You will need to manage the Perl internal stack yourself. Read on.

=item 3

    int foo(SV*, ...) {

Just like in C, the ellipsis syntax indicates that an unknown number of arguments will be passed in. Again you will need to access the Stack manually. C<Inline> provides a bunch of C macros that make it pretty easy to do.

=item 4

    void foo(SV*, ...) {

This is just a combination of the 2 & 3. It's another way of saying, "I can handle everything myself, thank you".

=back

=head2 Chip the Glasses and Crack the Plates. That's what Bilbo Baggins Hates

Internally, Perl is centered around a stack, commonly referred to as the Stack. A stack is a just an array that you only access from one end. Computer scientists like to compare it to a spring-loaded stack of dinner plates in a cafeteria. Perl uses the Stack to pass scalar arguments (plates) to a subroutine. When the subroutine gets control, it removes (or "pops") the plates from the Stack. Before the subroutine returns control, it places (or "pushes") its return value plates back onto the Stack.

You do this all the time in Perl without knowing it, using C<@_> and C<return>. With C<Inline>, you need to delve a bit into Perl's internals. If you ever look into the Perl source code itself, you'll undoubtedly find references to wizards, elves, hobbits and such. Fear not, for C<Inline> can help you slay the dragons.

C<Inline> provides the following C macros for dealing with the Stack:

=over 4

=item Inline_Stack_Vars

You'll need to use this one, if you want to use the others. It sets up a few local variables: C<sp>, C<items>, C<ax> and C<mark>, for use by the other macros. It's not important to know what they do, but I mention them to avoid possible name conflicts.

=item Inline_Stack_Items

Returns the number of arguments passed in on the Stack.

=item Inline_Stack_Item(i)

Refers to a particular C<SV*> in the Stack, where C<i> is an index number starting from zero. Can be used to get or set the value.

=item Inline_Stack_Reset

Use this before pushing anything back onto the Stack. It resets the internal Stack pointer to the beginning of the Stack.

=item Inline_Stack_Push(sv)

Push a return value back onto the Stack. The value must be of type C<SV*>.

=item Inline_Stack_Done

After you have pushed all of your return values, you must call this macro.

=item Inline_Stack_Return(n)

Return C<n> items on the Stack.

=item Inline_Stack_Void

A special macro to indicate that you really don't want to return anything. Same as:

    Inline_Stack_Return(0);

=back

The C type C<SV*> deserves an explanation. C<SV> is simply the name of the internal structure that Perl uses to hold scalars. It stands for "Scalar Value". The Stack, therefore, is an array of pointers to C<SV>. Perl provides a slew of helper macros for getting data in and out of SV-s (and AV-s, HV-s, RV-s, GV-s, etc). See C<perldoc perlapi> and C<perlguts> for all the details. (You I<are> using Perl 5.6 aren't you? <FOOTNOTE #3>)

Another example should help clear the fog. This function will take as its input a list of strings which are the names of Perl global scalars. It will check each scalar and return the values of those that actually exist and contain a string.

    # scalars.pl
    use Inline;
    Inline->import(C => <DATA>);
    $, = '/';     # Set print list separator
    
    ($scalar1, $scalar2, $scalar3) = ('paper', 'scissors', 42);
    print get_scalars(qw(main::scalar2 main::scalar4 
	                 main::scalar3 main::scalar1));
    print "\n";

    $scalar4 = "Inline";
    undef $scalar1;
    "$scalar3";   # Force scalar to string
    print get_scalars(qw(main::scalar2 main::scalar4 
	                 main::scalar3 main::scalar1));
    print "\n";
    
    __END__
    
    void get_scalars(SV* sv, ...) {
      Inline_Stack_Vars;
      int i;
      SV* name_sv; 
      SV* value_sv;
      char* name;
    
      Inline_Stack_Reset;
      for (i = 0; i < Inline_Stack_Items; i++) {
        name_sv = Inline_Stack_Item(i);
        name = SvPVX(name_sv);
        value_sv = perl_get_sv(name, FALSE);
        if (value_sv && SvPOK(value_sv))
          Inline_Stack_Push(value_sv);
      }
    
      Inline_Stack_Done;
    }

Here's what we get for output:

    > perl scalars.pl 
    scissors/paper
    scissors/Inline/42

The first time we call C<get_scalars> it fails to return C<$scalar4> because it is not defined, and C<$scalar3> because it's not a string. In the second case, C<$scalar4> is defined (and thus returned), C<$scalar1> gets undefined (and thus ignored), and C<$scalar3> is returned because it is now a string.

The more important thing is that we can handle list input and list output with relative ease. You'll notice that I snuck in a few Perl internal macro calls. C<SvPVX> returns the string (C<char*>) from an C<SV> variable. C<SvPOK> indicates whether an C<SV> has a string component or not, and C<perl_get_sv> (C<get_sv> in Perl 5.6) returns an C<SV> from Perl's internal symbol table. You can read about these and many, many more in 'C<perldoc perlapi>'.

=head2 The Inline Outline

Let's take a break from I<using> C<Inline> and examine exactly how it does its magic. Inquiring minds want to know. The C<Inline> module let's you take C source code and effectively C<eval> it into Perl at run time. What, exactly, is going on under the hood to make all of this work?

Here is a basic outline of what happens each time you invoke C<Inline>:

=over 4

=item 1) Receive the Source Code

C<Inline> gets the source code from your script or module with a statement like the following:

    use Inline C => 'source code';

where 'C' is the programming language used, and C<'source code'> is the actual source code itself in the form of a string. C<'source code'> can also be a file name, a reference to a subroutine, or anything else that will return source code. (More DWIMity)

Then C<Inline> prepends the following header includes to your source:

    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
    #include "INLINE.h"

This should be all the headers you will need for regular situations. The C<perl.h> file automatically includes all the standard C header files like C<stdio.h>.

=item 2) Check if the Source Code has been Compiled

C<Inline> only needs to compile the source code if it has not yet been compiled. But how can it tell if a mere string has been changed? It accomplishes this seemingly magical task in an extremely simple and straightforward manner. It runs the source text through the C<Digest::MD5> module to produce a 128-bit "fingerprint" which is virtually unique. The fingerprint (in hexadecimal) is I<mangled> together with the current package name and the name of the programming language. If the package is "C<main>", then the script name is added. Otherwise the module version number is stirred into the mix. This forms a unique name for the executable object. For instance, the C<vowels.pl> example produces a cached executable object called (on a Unix system):

    main_C_vowels_pl_bcc13cd1d188b32fc216cea883239ee3.so

If an object with that name already exists, then proceed to step 8. (No compilation is necessary)

=item 3) Find a Place to Build and Install

At this point C<Inline> knows it needs to compile the source code. The first thing to figure out is where to create the great big mess associated with compilation, and where to put the object when it's done.

By default C<Inline> will try to build and install under the first one of the following places that is writable directory:

     1) $ENV{PERL_INLINE_BLIB} <FOOTNOTE #4>
        (The PERL_INLINE_BLIB environment variable overrides all else)
     2) ./blib_I/  
        (The current directory, unless you're in your home directory)
     3) $bin/blib_I/
        (Where '$bin' is the directory that the script is in)
     4) $ENV{HOME}/blib_I/
        (Under your home directory)
     5) $ENV{HOME}/.blib_I/
	(Same as above but more discrete)

If none of those exist, C<Inline> will attempt to create and use one of following:

     6) $bin/blib_I/ 
     7) ./blib_I/ 

Optionally, you can configure C<Inline> to build and install exactly where you want, using C<Inline::Config>. In the unlikely event that C<Inline> cannot find a place to build, it will croak.

=item 4) Parse the Source for Semantic Cues

C<Inline> uses the module C<Parse::RecDescent> to parse through your chunks of source code and look for things that it can create run-time bindings to. For instance, in C it looks for all of the function definitions and breaks them down into names and data types. These elements are used to correctly bind the C function to a Perl subroutine.

=item 5) Create the Build Environment

Now C<Inline> can take all of the gathered information and create an environment to build your source code into an executable object. Without going into all the details, it just creates the appropriate directories and source files.

=item 6) Compile the Code and Install the Executable

The planets are in alignment. Now for the easy part. C<Inline> just does what you would do to install a module. 

    perl Makefile.PL
    make
    make test     # (Inline skips this one)
    make install

If something goes awry, C<Inline> will croak with a message indicating where to look for more info.

=item 7) Tidy Up

By default, C<Inline> will remove all of the mess created by the build process, assuming that everything worked. If the compile fails, C<Inline> will leave everything intact, so that you can debug your errors. Running something like:

    perl -MInline=NOCLEAN example.pl

will also prevent C<Inline> from cleaning up. (Just in case you want to poke around in the C<blib_I> directory)

=item 8) DynaLoad the Executable

C<Inline> uses Perl's C<DynaLoader> module to pull your external object into Perl-space. Now you can call all of your C functions like Perl subroutines. Wheeee!

=back

=head2 CPAN run. Run PAN, run.

So far, all the examples have been Perl I<scripts>, but C<Inline> is excellent for creating Perl modules as well, like the ones found on the CPAN. Modules that use C code as well as Perl are called "extension modules". This section describes how to create an extension module that can be uploaded to CPAN.

Let's create a module called C<Math::Simple> that provides four functions: C<add>, C<subtract>, C<multiply>, and C<divide>. We'll assume you're using some kind of Unix <FOOTNOTE #5>. Execute the following commands:

    > h2xs -PAXn Math::Simple 
    Writing Math/Simple/Simple.pm
    Writing Math/Simple/Makefile.PL
    Writing Math/Simple/test.pl
    Writing Math/Simple/Changes
    Writing Math/Simple/MANIFEST
    > cd Math/Simple 
    > ls
    Changes  MANIFEST  Makefile.PL  Simple.pm  test.pl

The C<h2xs> program is useful even if you're not using XS. It generates all of the files you'll need to distribute your module. The C<-X> and C<-A> switches prevent it from generating a lot of XS specific stuff that you won't need. The C<-P> switch prevents the generation of sample POD documentation. Doc is very important for a distributed module, but it gets in the way of the C<Inline> code. Put your doc in a separate file called C<Simple.pod> and add an entry for it in the C<MANIFEST> file. <FOOTNOTE #6>

Now edit C<Simple.pm> to look something like this:

    package Math::Simple;
    
    use strict;
    use vars qw($VERSION @ISA @EXPORT_OK);
    require Exporter;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(add subtract multiply divide);
    BEGIN {
        $VERSION = '1.23';
    }
    
    use Inline;
    Inline->import(C => <DATA>);
    
    1;
    
    __DATA__
    
    double add(double x, double y) {
      return x + y;
    }
    
    double subtract(double x, double y) {
      return x - y;
    }
    
    double multiply(double x, double y) {
      return x * y;
    }
    
    double divide(double x, double y) {
      if (! y)
        croak("Error! Attempt to divide by zero\n");
      return x / y;
    }

This should be pretty familiar stuff. The important thing is that you define C<$VERSION> before invoking C<Inline>. Since C<Inline> is often invoked at compile time, it is best to put the C<$VERSION> line inside a C<BEGIN> block. Also notice the C<croak> statement in the C<divide> function. This is the correct way to C<die> from C.

Next, add this line to the top of your C<test.pl> file:

    use Inline SITE_INSTALL;

You must do this to distribute the module properly. It ensures that the module will get installed in the proper place by the recipient. It also requires the person doing the install of C<Math::Simple> to use the C<make test> command. (People sometimes skip this part of the install process.)

If you add the following line to Makefile.PL, it will verify that the proper version of C<Inline.pm> is already installed on the user's system.

    PREREQ_PM => {Inline => 0.25},

Finally, run these commands:

    > perl Makefile.PL
    > make
    > make test
    > make install  # Optional
    > make dist

The C<make install> command will install the module on your local system. When it's all working, the C<make dist> command will produce the file C<Math-Simple-1.23.tar.gz>. This is your complete distribution package, ready to go to the CPAN.

=head2 When the Going Gets Tough...

...the tough use C<Inline::Config>! 

C<Inline> tries to do the right thing as often as possible. But sometimes you may need to override the default actions. This is where C<Inline::Config> comes to the rescue. C<Inline::Config> gives you a more fine-grained control over the entire process.

An important point to remember is that the config settings must be done I<before> C<Inline> receives the source code. Since a "C<use>" happens at (C<Perl>'s) compile time, you may need to do something like this:

    BEGIN {
        use Inline;
        $Inline::Config::PRINT_INFO = 1;
        Inline::Config::Force_Build(1);
	Inline::Config->makefile('LIBS' => ['-lm']);
    }
    
    use Inline C => "C code goes here...";

If you were really paying attention, you would have noticed three different syntaxes for setting options. C<Inline::Config> has many ways to set its options.

A particularly handy way to set options temporarily, is to specify them on the command line. To cut down on the typing, several options have terse command line versions. They are also case insensitive. I use these all the time:

    perl -MInline=INFO script.pl
    perl -MInline=Force,NoClean,Info script.pl
    perl -MInline=clean script.pl

C<INFO> tells C<Inline> to print a small report about the status of the Inlined code. C<FORCE> forces a build to happen even if the cached object is up to date, and C<NOCLEAN> will leave the build mess intact, so that you can inspect it. The C<CLEAN> option tells C<Inline> to clean up all previous messes that it knows about. (Remember, everything is under one C<blib_I> directory, so it's a manageable mess)

You can even get information about any installed module that uses C<Inline> with a one-liner like:

    > perl -MInline=Info -MMath::Simple -e 42
    <-----------------------Information Section----------------------------------->
    
    Information about the processing of your Inline C code:
    
    Your module is already compiled. It is located at:
    /usr/local/lib/perl5/site_perl/5.6.0/i686-linux/auto/Math/Simple_C_1_23_9cddc5e3
    bf29ec8e1b4218f2de670c59/Simple_C_1_23_9cddc5e3bf29ec8e1b4218f2de670c59.so
    
    The following Inline C function(s) have been successfully bound to Perl:
            double add(double x, double y)
            double divide(double x, double y)
            double multiply(double x, double y)
            double subtract(double x, double y)
    
    <-----------------------End of Information Section---------------------------->

There is a special option called C<REPORTBUG>. When you run into a problem, and suspect that it is the fault of C<Inline>, just issue the following command. 

    perl -MInline=REPORTBUG script.pl

Explicit instructions will be printed on the screen, telling you how to report the problem.

See the C<Inline::Config> documentation for more information about configuration issues.

=head2 XS and SWIG

This is my opinionated rant on why C<Inline> is better than XS and SWIG. If you're already convinced that C<Inline> is the best way to extend Perl, feel free to skip this section. SWIG (Simplified Wrapper and Interface Generator) is more or less a generic version of XS, that supports other scripting languages as well. Since this rant applies equally to both methods, I will only talk about XS.

XS (External Subroutines) is a mini "glue" language that works together with the C<h2xs> template generating tool and the C<xsubpp> translating compiler. The basic idea is that you run C<h2xs> against some existing C library's header files. This creates a Perl module, an XS interface file, and a C<Makefile.PL>. Then you run the normal Perl install commands and presto, you have a Perl module that gives you full access to that library's API.

If you can get it to work that easily, then by all means, use XS. 

The first problem that you will undoubtedly run into is that you need to tweak each of the generated files. A lot. That means you'll need to read a lot of documentation on the format of those files. You'll do most of the tweaking in the C<Foo.xs> file. XS gives you a dozen or so special keywords to help you tweak. Keywords like C<INIT>, C<PREINIT>, C<CODE> and C<PPCODE> allow you to sprinkle bits of C code around the calling of the function. Knowing how all of these bits get pasted together at compile time is the stuff of legends.

Another problem is typemaps. They are the mechanisms that translate Perl data types to C and vice versa. XS provides a lot of defaults. But some of them actually update the input arguments themselves. This is good in C, but horrible in Perl. If you use these literally mapped function calls, you'll end up providing a very confusing interface from the standpoint of a Perl programmer. Also, if your existing library uses any but the simplest of types and typedefs, you'll have to write your own typemaps in yet another file called C<typemaps>.

To make I<C<Inline>> use an existing API, you'll need to write your own wrapper function for each existing function that you want to expose. If this seems crummy at first, consider that all of your code will be in one file C<Foo.pm> and that it will all be laid out in the true order of execution, instead of being masked by a lot of extra syntax. And you don't have to run C<make> every time you tweak.

If you're not using an existing API, then choosing C<Inline> should be a no-brainer. One of the best things about C<Inline> is that you can use it from a script. With XS and SWIG you always need to create a full-blown module.

=head2 On the Inside, Looking Out

As you journey beyond the examples and into more complex C programming, you may find yourself clicking your heels from time to time. "I'm not in Perl anymore!", you might say. But if you think about it, you never really left. You're merely on the dark side now. Just use the force.

The full power of Perl is at your fingertips, if you know how to use it. For example, in Perl, memory is automatically allocated each time you mention a new variable. If you add text to a string variable, Perl automatically allocates more memory. When the variable goes out of scope, all the memory is automatically freed. But in C you need to use C<malloc> and C<free> to manage buffers. Right?

Why not just use the power of Perl? You can ask Perl for a new anonymous scalar (C<SV>) at any time. You can ask Perl to extend it for you, and you can even tell Perl to free it at some point I<after> your C function returns.

Here's a simple example using a function that takes a hash reference and returns its values as a comma separated string. Of course, we'll need to build the return value in a buffer of unknown size.

    # hash_keys.pl
    use Inline C => <<'END_OF_C_CODE';
    
    void hash_values(SV* hash_ref) {
      Inline_Stack_Vars;
      HV* hash;
      HE* hash_entry;
      int num_keys, i;
      SV* buffer;
      SV* sv_val;
    
      if (! (SvROK(hash_ref) && SvTYPE(SvRV(hash_ref)) == SVt_PVHV))
        croak("Error. Expected a hash reference");
      hash = (HV*)SvRV(hash_ref);
      num_keys = hv_iterinit(hash);
    
      buffer = NEWSV(0, 0);
      for (i = 0; i++ < num_keys;) {
        hash_entry = hv_iternext(hash);
        sv_val = hv_iterval(hash, hash_entry);
        sv_catpvf(buffer, "%s%s", SvPV(sv_val, PL_na),
                  (i < num_keys) ? "," : "");
      }
    
      Inline_Stack_Item(0) = sv_2mortal(buffer);
      Inline_Stack_Return(1);
    }
    
    END_OF_C_CODE
    
    %hash = (
	     Who  => 'Ingy',
	     What => 'Loves',
	     Whom => 'Perl',
	    );
    
    print hash_values(\%hash), "\n";

Run it and you get:

    > perl ./hash_keys.pl 
    Perl,Loves,Ingy

I've just presented you with dozen or so new calls. I leave it you to find out how they all work. Strange days indeed.(Most peculiar mama)

=head2 The Future

The primary goal of C<Inline> is to make it as easy as possible to extend Perl. I will continue to add features for debugging and other real-life situations. I am also I<considering> writing C<Inline::C::Typemaps>, which would provide a library of useful typemaps and support for adding your own.

From the start, C<Inline> was intended to allow use of other programming languages within Perl. This is not limited to C. Other languages I would like to support include:

=over 4

=item C++

=item Fortran

=item Pascal

=item Python

=back

=head2 On Your Mark

I did some benchmark testing on the C<vowels.pl> script. The C<vowel_scan> subroutine was called 1000 times with the contents of C</usr/dict/words> as its input string. This is a huge string (409093 bytes). It took 16.0 secs to run. That's 0.0160 secs/call. 

A similar subroutine written in Perl took 2.96 secs/call (186 times slower than C). An optimized version of this routine, which used only numeric comparisons, took 2.54 secs/call. Better, but not much.

If you think this an argument against Perl, think again. The algorithm was then coded as a Perl one-liner with creative use of the C<tr> command. 

    sub vowel_scan{$_[0]=~tr/aeiouAEIOU// / $_[0]=~tr/a-zA-Z//}

Pretty? Maybe not. Fast? This ran at 0.0169 secs/call. Less than a millisecond slower than the C function. And it still works in EBCDIC. TMTOWTDI!

=head1 AUTHOR

Brian Ingerson <INGY@cpan.org> is a full-time employee of a Utah-based library automation software vendor and telecommutes each day from his home in Seattle Washington. He is a devoted member of the Seattle Perl Users Group. http://www.halcyon.com/spug/ When he's not writing code, he can usually be found in bed, sleeping.

=head1 Packages Used:

    Inline...............CPAN
    Inline::Config.......CPAN
    Parse::RecDescent....CPAN
    Digest::MD5..........CPAN

=head1 Footnotes

=over 4

=item 1

Actually the C<h2xs> facility will I<create> all of these for you. But it's up to you to modify and maintain them.

=item 2

Technically, C<SV*> is all you need. Come to think of it, you don't even need that.

=item 3

C<Inline> works with Perl 5.005 and above, but the C<perlapi> documentation is only available with 5.6.0 or higher.

=item 4

C<blib> stands for "build library" in Perl-speak. It is a temporary staging directory that gets created when you install a Perl module on your system. C<blib_I> is the C<Inline> version of the same concept.

=item 5

C<Inline> works an all flavors of Unix and MS Windows provided that you have the proper development environment. Read the C<Inline> documentation for more information.

=item 6

This is just one way to do it. If you really want POD inside your module, then put the C source code in a string instead of the C<__DATA__> section.

=back
