----- Forwarded message from Nicholas Clark <nick@unfortu.net> -----

From: Nicholas Clark <nick@unfortu.net>
Date: Fri, 11 Oct 2002 23:59:19 +0100
To: Brian Ingerson <ingy@ttul.org>
Cc: Nicholas Clark <nick@ccl4.org>, Inline Mailing List <inline@perl.org>
Subject: Re: Inline-0.44-TRIAL1.tar.gz
User-Agent: Mutt/1.3.25i

On Thu, Oct 03, 2002 at 12:06:45PM -0700, Brian Ingerson wrote:
> Could you take a few minutes to outline these nits? That would be a big help.
> Basically I want to know all of the different function signature forms that
> an XS person would expect Inline to bind to. 

OK. Appended is (I believe) all the combinations and permutations of
char * pointers one could define a function with.

I believe that the cases where the function names differ only in a number at
the end (such as three_s_v0 and three_s_v1) are different permutations of the
same type, but where the names differ IIRC the functions actually have
(subtly) different types. And IIRC the whitespace on either side of * is
optional.

I'd like to be able to define functions as void, rather than currently having
to use () - so foo below should work. long (and short) are actually prefixes
for int, so I'd like the flexibility of being allowed to put the int in, as
in bar. Likewise signed and unsigned can omit the size specifier and it
defaults to int (bar below). I can also omit the size specifier on const and
get a const int. (and a warning on gcc, but IIRC it's ANSI legal)

void foo (void) {
}

void bar (long int a) {
}

void baz (unsigned a) {
}

void er_what_comes_next (const a) {
}


I can combine these - a "const unsigned" is legal, but I don't know how well
it parses currently. I fear this may cause some "fun" in the parser as
things like "unsigned" can be either a prefix to a second token that is the
type, or the type themselves. (And you can't work out until you've read the
next two tokens and found the variable name and the ',' or ')' that follows)

Other people have commented about being allowed to define parameters that are
3 symbols, such as "struct foo bar" being a bar of type struct foo.

At the moment I think Inline 0.43 can cope with a parameter of "unsigned",
but not one of "unsigned int" because "unsigned" is one token, and that
appears to be what it expects.

IIRC in C++ you can omit the name on a parameter that isn't used in the
function body, and it would be nice if the Inline parser knew about that.
[I think that C++ also outlaws the use of "const" alone to mean "const int",
as otherwise there is a corner case of

struct foo;

void bar (const foo);

meaning with C:   bar takes a parameter of type const int, name foo
        with C++: bar takes an unnamed parameter of type const struct foo

because C++ unifies the struct/class and type namespaces. (if I understand
all the terms correctly)]

Nicholas Clark

PS here are the combinations and permutations of a single pointer to char:

void one (char *foo) {
}

void two (const char *foo) {
}

void three (char *const foo) {
}

void four (const char *const foo) {
}

void one_u (unsigned char *foo) {
}

void two_u0 (const unsigned char *foo) {
}

void two_u1 (unsigned const char *foo) {
}

void three_u (unsigned char *const foo) {
}

void four_u0 (const unsigned char *const foo) {
}

void four_u1 (unsigned const char *const foo) {
}

void one_s (signed char *foo) {
}

void two_s0 (signed const char *foo) {
}

void two_s1 (const signed char *foo) {
}

void three_s (signed char *const foo) {
}

void four_s0 (const signed char *const foo) {
}

void four_s1 (signed const char *const foo) {
}


void one_v (volatile char *foo) {
}

void two_v0 (const volatile char *foo) {
}

void two_v1 (volatile const char *foo) {
}

void three_v (volatile char *const foo) {
}

void four_v0 (const volatile char *const foo) {
}

void four_v1 (volatile const char *const foo) {
}

void one_u_v0 (unsigned volatile char *foo) {
}

void one_u_v1 (volatile unsigned char *foo) {
}

void two_u_v0 (const unsigned volatile char *foo) {
}

void two_u_v1 (const volatile unsigned char *foo) {
}

void two_u_v2 (volatile const unsigned char *foo) {
}

void two_u_v3 (volatile unsigned const char *foo) {
}

void two_u_v4 (unsigned const volatile char *foo) {
}

void two_u_v5 (unsigned volatile const char *foo) {
}

void three_u_v0 (unsigned volatile char *const foo) {
}

void three_u_v1 (volatile unsigned char *const foo) {
}

void four_u_v0 (const unsigned volatile char *const foo) {
}

void four_u_v1 (const volatile unsigned char *const foo) {
}

void four_u_v2 (volatile const unsigned char *const foo) {
}

void four_u_v3 (volatile unsigned const char *const foo) {
}

void four_u_v4 (unsigned const volatile char *const foo) {
}

void four_u_v5 (unsigned volatile const char *const foo) {
}

void one_s_v0 (signed volatile char *foo) {
}

void one_s_v1 (volatile signed char *foo) {
}

void two_s_v0 (const signed volatile char *foo) {
}

void two_s_v1 (const volatile signed char *foo) {
}

void two_s_v2 (volatile const signed char *foo) {
}

void two_s_v3 (volatile signed const char *foo) {
}

void two_s_v4 (signed const volatile char *foo) {
}

void two_s_v5 (signed volatile const char *foo) {
}

void three_s_v0 (signed volatile char *const foo) {
}

void three_s_v1 (volatile signed char *const foo) {
}

void four_s_v0 (const signed volatile char *const foo) {
}

void four_s_v1 (const volatile signed char *const foo) {
}

void four_s_v2 (volatile const signed char *const foo) {
}

void four_s_v3 (volatile signed const char *const foo) {
}

void four_s_v4 (signed const volatile char *const foo) {
}

void four_s_v5 (signed volatile const char *const foo) {
}

----- End forwarded message -----
